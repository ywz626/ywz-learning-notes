# 二分算法

二分模板：

模板1

当我们将区间[l,r]划分成[l,mid]和[mid+1,r]时，其更新操作是r=mid或者l=mid+1，计算mid时不需要加1，即mid=(l+r)/2。

C++/java代码模板：

```c++
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = (l + r)/2;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

模板2

当我们将区间[l,r]划分成[l,mid−1]和[mid,r]时，其更新操作是r=mid−1或者l=mid，此时为了防止死循环，计算mid时需要加1，即mid=(l+r+1)/2。

C++/java 代码模板：

```c++
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = ( l + r + 1 ) /2;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

为什么两个二分模板mid取值不同？

对于第二个模板，当我们更新区间时，如果左边界l更新为l=mid，此时mid的取值就应为mid=(l+r+1)/2。因为当右边界r=l+1时，此时mid=(l+l+1)/2，下取整，mid仍为l，左边界再次更新为l=mid=l，相当于没有变化，while循环就会陷入死循环。因此，我们总结出来一个小技巧，当左边界要更新为l=mid时，我们就令 mid=(l+r+1)/2，上取整，此时就不会因为r取特殊值r=l+1而陷入死循环了。

而对于第一个模板，如果左边界l更新为l=mid+1，是不会出现这样的困扰的。因此，大家可以熟记这两个二分模板，基本上可以解决99以上的二分问题，再也不会被二分的边界取值所困扰了。

什么时候用模板1？什么时候用模板2？

假设初始时我们的二分区间为[l,r]，每次二分缩小区间时，如果左边界l要更新为 l=mid，此时我们就要使用模板2，让 mid=(l+r+1)/2，否则while会陷入死循环。如果左边界l更新为l=mid+1,此时我们就使用模板1，让mid=(l+r)/2。因此，模板1和模板2本质上是根据代码来区分的，而不是应用场景。如果写完之后发现是l=mid，那么在计算mid时需要加上1，否则如果写完之后发现是l=mid+1，那么在计算mid时不能加1。

为什么模板要取while( l < r)，而不是while( l <= r)？

本质上取l<r 和 l<=r是没有任何区别的，只是习惯问题，如果取l<=r，只需要修改对应的更新区间即可。

while循环结束条件是l >= r，但为什么二分结束时我们优先取r而不是l?

二分的while循环的结束条件是l>=r，所以在循环结束时l有可能会大于r，此时就可能导致越界，因此，基本上二分问题优先取r都不会翻车。 
